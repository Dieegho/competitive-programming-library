//          Copyright Diego Ram√≠rez August 2015
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

#ifndef DJP_GRAPH_MIN_ST_CUT_HPP
#define DJP_GRAPH_MIN_ST_CUT_HPP

#include <djp/graph/edmonds_karp_max_flow.hpp>

#include <stack>   // for std::stack
#include <utility> // for std::declval
#include <vector>  // for std::vector
#include <cstddef> // for std::size_t

namespace djp {

/// \brief Finds the minimum s-t cut in the given graph.
///
/// A s-t cut determines a s-t cut-set. A s-t cut-set is a set of edges that
/// when removed from the graph make the maximum flow from \p source to \p
/// target equal to 0. A minimum s-t cut is any s-t cut which minimizes the
/// total sum of edge's weights in the s-t cut-set.
///
/// This algorithm uses the Edmonds-Karp maximum flow algorithm to determine the
/// weight of the min s-t cut-set as its value is equal to the maximum flow
/// from \p source to \p target (See max-flow min-cut theorem).
///
/// The \p reachable output parameter is used to record the reachable vertices
/// from \p source through the residual graph (generated by the Edmonds-Karp
/// algorithm). All edges going from reachable vertices to unreachable vertices
/// form part of the s-t cut-set.
///
/// \tparam Graph The graph type. Must model a network flow so it can be used as
/// input in a max flow algorithm.
///
/// \param graph The target graph (a network flow).
/// \param source Descriptor of the source vertex.
/// \param target Descriptor of the target vertex.
/// \param[out] reachable Map vector, it will be modified in such a way that \c
/// reachable[v] evaluates to \c true iff the vertex \c v is reachable from \p
/// source through the residual graph.
///
/// \returns The weight of the min s-t cut.
///
/// \pre <tt>source != target</tt>
///
/// \par Complexity
/// Same as the underlying max-flow algorithm. In this case:
/// <tt>O(V * E^2)</tt> (See Edmonds-Karp max-flow for details).
///
template <typename Graph>
auto min_st_cut(const Graph &graph, const size_t source, const size_t target,
                std::vector<bool> &reachable)
    -> decltype(edmonds_karp_max_flow(graph, source, target)) {

  const auto max_flow = edmonds_karp_max_flow(graph, source, target);

  reachable.assign(graph.num_vertices(), false);
  std::stack<size_t> stack;

  reachable[source] = true;
  stack.push(source);
  while (!stack.empty()) {
    const size_t current = stack.top();
    stack.pop();
    for (const auto *edge : graph.out_edges(current)) {
      const size_t neighbor = edge->target;
      if (reachable[neighbor])
        continue; // Already discovered.
      if (edge->flow == edge->capacity)
        continue; // Can't navigate through saturated edges.
      reachable[neighbor] = true;
      stack.push(neighbor);
    }
  }
  return max_flow;
}

} // end namespace djp

#endif // Header guard
